#include <bits/stdc++.h>

#include <SFML/Window.hpp>
#include <SFML/OpenGL.hpp>
#include <SFML/Graphics.hpp>
#include <SFML/Audio.hpp>

#include "Renderer.h"

#include "Node.h"
using namespace std;
using namespace pg;

double maxY = 700;
double maxX = 700;
int N = 100;


vector<vector<shared_ptr<Node>>> grid;
SegmentField segfield;
int fromCoord( int i, int j, int n )
{
    int var = i * n + j;
    return var;
}

void populateGrid( double n )
{
    double varX = maxX / n;
    double varY = maxY / n;
    grid.resize( n );
    for ( int i = 0 ; i < n ; i++ ) {
        grid[i].resize( n );
        for ( int j = 0 ; j < n ; j++ ) {
            grid[i][j] = shared_ptr<Node>( new Node( i, j, varX,N ) );

        }
    }
}
int mod(int a,int b)
{
    return(b + (a%b)) % b;
}

void populateSegs(int segs)
{
    for ( int i = 0 ; i < N ; i++ ) {
        for ( int j = 0 ; j < N ; j++ ) {
            auto s= make_shared<Segment>();

            for (int w=0; w<= segs ; w++ ) {
                for (int z=0; z<= segs ; z++ ) {
                    if(abs(w) + abs(z)>segs)
                        continue;

                    int x = mod(i + w,N);
                    int _x =mod( i - w,N);
                    int y = mod(j +z,N);
                    int _y =mod( j-z,N);
                    s->add(grid[_x][y]);
                    s->add(grid[_x][_y]);
                    s->add(grid[x][_y]);
                    s->add(grid[x][y]);
                }
            }
            s->setOwner( grid[i][j]);
            grid[i][j]->connections[s]=0;
            segfield[i][j]=s;
        }
    }


}

CampoVals getVals()
{
    CampoVals vals;
    vals.resize( N );
    for ( int i = 0 ; i < N ; i++ ) {
        vals[i].resize( N );
        for ( int j = 0 ; j < N ; j++ ) {
            vals[i][j] = grid[i][j]->value;
        }
    }
    return vals;
}

int mysin(int a){
    double y= sin(a)*100;
    return y;
}

int main()
{

    srand(time(0));
    Renderer win = Renderer( { maxX, maxY } );

    populateGrid( N );
    for ( int i = 0 ; i < N ; i++ ) {
        for ( int j = 0 ; j < N ; j++ ) {
            win.add( grid[i][j] );
        }
    }
    populateSegs(1);
    std::cout << "Starting" << std::endl;
    win.beginAssync();
    win.running=true;

 //  grid[51][70]->weightValue=-100;
 //  grid[50][50]->value=100;

  // grid[50][70]->value=100;

   //grid[5][5]->value=100;



 //grid[150][150]->weightValue=10000;

     //    int i = rand()%70-35;

    // grid[2][1]->value=-i*i*i-8;

    Node::desire=30;

    int i =0;
    while ( win.running) {
      //  if(i%11)
         grid[2][10]->value=10;

        grid[4][10]->value=20;
        i++;
       //  grid[2][10]->value=1;
         // grid[2][3]->value=20;

      //  grid[70][10]->value=10;
       // grid[30][10]->value=20;


     //   grid[30][80]->desire=30;


    // grid[49][70]->weightValue=10000;
     //
     //   grid[100][150]->value=5;
       // std::this_thread::sleep_for ( std::chrono::milliseconds ( 1000) );
        CampoVals vals = getVals();

        // win.begin();
        for ( int i = 0 ; i < N ; i++ ) {
            for ( int j = 0 ; j < N ; j++ ) {
                grid[i][j]->update( vals );
            }
        }
        for ( int i = 0 ; i < N ; i++ ) {
            for ( int j = 0 ; j < N ; j++ ) {
                segfield[i][j]->update(vals);
            }
        }
    }

}
